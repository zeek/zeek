.. _intro-scripting:

####################
 Intro to Scripting
####################

We have previously seen Zeek’s scripting language, but have not examined
the scripting language in depth. This scripting tutorial will consist of
two parts.

First, a simple walkthrough of language features and how to do various
common tasks. Where needed, there will be links to the scripting
reference (TODO: link) section to learn more.

Second, We will build up a small Zeek script from scratch. This should
get many of the necessary parts for any given detection. This is meant
to supplement other references - namely, try.zeek.org and the scripting
reference sections. try.zeek.org provides a more thorough, interactive
tutorial. The scripting reference goes through each language construct.
This is meant to simply understand the essential components of the
scripting language.

This tutorial will assume some knowledge of programming languages like
Python before getting started. Specifics of Zeek script will be
discussed, but any general programming concepts will not. TODO: Change
this disclaimer?

**********
The Basics
**********

Events
======

Zeek's scripting language is event driven which is a gear change from
the majority of scripting languages with which most users will have
previous experience.  Scripting in Zeek depends on handling the events
generated by Zeek as it processes network traffic, altering the state
of data structures through those events, and making decisions on the
information provided.  This approach to scripting can often cause
confusion to users who come to Zeek from a procedural or functional
language, but once the initial shock wears off it becomes more clear
with each exposure.

Zeek's core acts to place events into an ordered "event queue",
allowing event handlers to process them on a first-come-first-serve
basis.  In effect, this is Zeek's core functionality as without the
scripts written to perform discrete actions on events, there would be
little to no usable output.  As such, a basic understanding of the
event queue, the events being generated, and the way in which event
handlers process those events is a basis for not only learning to
write scripts for Zeek but for understanding Zeek itself.

Gaining familiarity with the specific events generated by Zeek is a big
step towards building a mind set for working with Zeek scripts.  The
majority of events generated by Zeek are defined in the
built-in-function (``*.bif``) files which also act as the basis for
online event documentation.  These in-line comments are compiled into
an online documentation system using Zeekygen.  Whether starting a
script from scratch or reading and maintaining someone else's script,
having the built-in event definitions available is an excellent
resource to have on hand.  For the 2.0 release the Zeek developers put
significant effort into organization and documentation of every event.
This effort resulted in built-in-function files organized such that
each entry contains a descriptive event name, the arguments passed to
the event, and a concise explanation of the functions use.

.. code-block:: zeek

   ## Generated for DNS requests. For requests with multiple queries, this event
   ## is raised once for each.
   ##
   ## See `Wikipedia <http://en.wikipedia.org/wiki/Domain_Name_System>`__ for more
   ## information about the DNS protocol. Zeek analyzes both UDP and TCP DNS
   ## sessions.
   ##
   ## c: The connection, which may be UDP or TCP depending on the type of the
   ##    transport-layer session being analyzed.
   ##
   ## msg: The parsed DNS message header.
   ##
   ## query: The queried name.
   ##
   ## qtype: The queried resource record type.
   ##
   ## qclass: The queried resource record class.
   ##
   ## .. zeek:see:: dns_AAAA_reply dns_A_reply dns_CNAME_reply dns_EDNS_addl
   ##    dns_HINFO_reply dns_MX_reply dns_NS_reply dns_PTR_reply dns_SOA_reply
   ##    dns_SRV_reply dns_TSIG_addl dns_TXT_reply dns_WKS_reply dns_end
   ##    dns_full_request dns_mapping_altered dns_mapping_lost_name dns_mapping_new_name
   ##    dns_mapping_unverified dns_mapping_valid dns_message dns_query_reply
   ##    dns_rejected non_dns_request dns_max_queries dns_session_timeout dns_skip_addl
   ##    dns_skip_all_addl dns_skip_all_auth dns_skip_auth
   event dns_request%(c: connection, msg: dns_msg, query: string, qtype: count, qclass: count%);

Above is a segment of the documentation for the event
:zeek:id:`dns_request` (and the preceding link points to the
documentation generated out of that).  It's organized such that the
documentation, commentary, and list of arguments precede the actual
event definition used by Zeek.  As Zeek detects DNS requests being
issued by an originator, it issues this event and any number of
scripts then have access to the data Zeek passes along with the event.
In this example, Zeek passes not only the message, the query, query
type and query class for the DNS request, but also a record used
for the connection itself.

.. _writing-scripts-connection-record:

The Connection Record Data Type
===============================

Of all the events defined by Zeek, an overwhelmingly large number of
them are passed the :zeek:type:`connection` record data type, in effect,
making it the backbone of many scripting solutions.  The connection
record itself, as we will see in a moment, is a mass of nested data
types used to track state on a connection through its lifetime.  Let's
walk through the process of selecting an appropriate event, generating
some output to standard out and dissecting the connection record so as
to get an overview of it.  We will cover data types in more detail
later.

While Zeek is capable of packet level processing, its strengths lay in
the context of a connection between an *originator* and a *responder*.

.. note::

   Zeek's notions of originator and responder aim to capture the
   natural roles of connection endpoints given the protocol
   information observed. They differ from the packet-level concepts of
   source and destination, as well as from higher-level abstractions
   such as client and server.

   Zeek's protocol analyzers determine originator and responder when
   establishing connection state, with the sender of the initial
   packet usually becoming the originator and the recipient becoming
   the responder. However, analyzers may subsequently *flip* the roles
   if protocol semantics suggest it. For example, in the presence of
   packet loss the first observed packet in a DNS transaction may
   indicate that it is in fact the response to a missing query. Zeek's
   DNS analyzer will flip the endpoint roles, making the sender of
   this packet the connection's responder.

Zeek defines events for the primary parts of the connection life-cycle,
such as the following:

* :zeek:see:`new_connection`
* :zeek:see:`connection_timeout`
* :zeek:see:`connection_state_remove`

Of the events listed, the event that will give us the best insight
into the connection record data type will be
:zeek:id:`connection_state_remove` .  As detailed in the in-line
documentation, Zeek generates this event just before it decides to
remove this event from memory, effectively forgetting about it.  Let's
take a look at a simple example script, that will output the connection record
for a single connection.

.. literalinclude:: connection_record_01.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

Again, we start with ``@load``, this time importing the
:doc:`base/protocols/conn </scripts/base/protocols/conn/index>` scripts which
supply the tracking and logging of general information and state of
connections.  We handle the :zeek:id:`connection_state_remove` event and simply
print the contents of the argument passed to it.  For this example we're
going to run Zeek in "bare mode" which loads only the minimum number of
scripts to retain operability and leaves the burden of loading
required scripts to the script being run.  While bare mode is a low
level functionality incorporated into Zeek, in this case, we're going
to use it to demonstrate how different features of Zeek add more and
more layers of information about a connection.  This will give us a
chance to see the contents of the connection record without it being
overly populated.

.. code-block:: console

   $ zeek -b -r http/get.trace connection_record_01.zeek
   [id=[orig_h=141.142.228.5, orig_p=59856/tcp, resp_h=192.150.187.43, resp_p=80/tcp], orig=[size=136, state=5, num_pkts=7, num_bytes_ip=512, flow_label=0, l2_addr=c8:bc:c8:96:d2:a0], resp=[size=5007, state=5, num_pkts=7, num_bytes_ip=5379, flow_label=0, l2_addr=00:10:db:88:d2:ef], start_time=1362692526.869344, duration=0.211484, service={

   }, history=ShADadFf, uid=CHhAvVGS1DHFjwGM9, tunnel=<uninitialized>, vlan=<uninitialized>, inner_vlan=<uninitialized>, conn=[ts=1362692526.869344, uid=CHhAvVGS1DHFjwGM9, id=[orig_h=141.142.228.5, orig_p=59856/tcp, resp_h=192.150.187.43, resp_p=80/tcp], proto=tcp, service=<uninitialized>, duration=0.211484, orig_bytes=136, resp_bytes=5007, conn_state=SF, local_orig=<uninitialized>, local_resp=<uninitialized>, missed_bytes=0, history=ShADadFf, orig_pkts=7, orig_ip_bytes=512, resp_pkts=7, resp_ip_bytes=5379, tunnel_parents=<uninitialized>], extract_orig=F, extract_resp=F, thresholds=<uninitialized>]

As you can see from the output, the connection record is something of
a jumble when printed on its own.  Regularly taking a peek at a
populated connection record helps to understand the relationship
between its fields as well as allowing an opportunity to build a frame
of reference for accessing data in a script.

Zeek makes extensive use of nested data structures to store state and
information gleaned from the analysis of a connection as a complete
unit.  To break down this collection of information, you will have to
make use of Zeek's field delimiter ``$``.  For example, the
originating host is referenced by ``c$id$orig_h`` which if given a
narrative relates to ``orig_h`` which is a member of ``id`` which is
a member of the data structure referred to as ``c`` that was passed
into the event handler. Given that the responder port
``c$id$resp_p`` is ``80/tcp``, it's likely that Zeek's base HTTP scripts
can further populate the connection record.  Let's load the
``base/protocols/http`` scripts and check the output of our script.

Zeek uses the dollar sign as its field delimiter and a direct
correlation exists between the output of the connection record and the
proper format of a dereferenced variable in scripts. In the output of
the script above, groups of information are collected between
brackets, which would correspond to the ``$``-delimiter in a Zeek script.

.. literalinclude:: connection_record_02.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek -b -r http/get.trace connection_record_02.zeek
   [id=[orig_h=141.142.228.5, orig_p=59856/tcp, resp_h=192.150.187.43, resp_p=80/tcp], orig=[size=136, state=5, num_pkts=7, num_bytes_ip=512, flow_label=0, l2_addr=c8:bc:c8:96:d2:a0], resp=[size=5007, state=5, num_pkts=7, num_bytes_ip=5379, flow_label=0, l2_addr=00:10:db:88:d2:ef], start_time=1362692526.869344, duration=0.211484, service={

   }, history=ShADadFf, uid=CHhAvVGS1DHFjwGM9, tunnel=<uninitialized>, vlan=<uninitialized>, inner_vlan=<uninitialized>, conn=[ts=1362692526.869344, uid=CHhAvVGS1DHFjwGM9, id=[orig_h=141.142.228.5, orig_p=59856/tcp, resp_h=192.150.187.43, resp_p=80/tcp], proto=tcp, service=<uninitialized>, duration=0.211484, orig_bytes=136, resp_bytes=5007, conn_state=SF, local_orig=<uninitialized>, local_resp=<uninitialized>, missed_bytes=0, history=ShADadFf, orig_pkts=7, orig_ip_bytes=512, resp_pkts=7, resp_ip_bytes=5379, tunnel_parents=<uninitialized>], extract_orig=F, extract_resp=F, thresholds=<uninitialized>, http=[ts=1362692526.939527, uid=CHhAvVGS1DHFjwGM9, id=[orig_h=141.142.228.5, orig_p=59856/tcp, resp_h=192.150.187.43, resp_p=80/tcp], trans_depth=1, method=GET, host=bro.org, uri=/download/CHANGES.bro-aux.txt, referrer=<uninitialized>, version=1.1, user_agent=Wget/1.14 (darwin12.2.0), request_body_len=0, response_body_len=4705, status_code=200, status_msg=OK, info_code=<uninitialized>, info_msg=<uninitialized>, tags={

   }, username=<uninitialized>, password=<uninitialized>, capture_password=F, proxied=<uninitialized>, range_request=F, orig_fuids=<uninitialized>, orig_filenames=<uninitialized>, orig_mime_types=<uninitialized>, resp_fuids=[FakNcS1Jfe01uljb3], resp_filenames=<uninitialized>, resp_mime_types=[text/plain], current_entity=<uninitialized>, orig_mime_depth=1, resp_mime_depth=1], http_state=[pending={

   }, current_request=1, current_response=1, trans_depth=1]]

The addition of the ``base/protocols/http`` scripts populates the
``http=[]`` member of the connection record.  While Zeek is doing a
massive amount of work in the background, it is in what is commonly
called "scriptland" that details are being refined and decisions
being made. Were we to continue running in "bare mode" we could slowly
keep adding infrastructure through ``@load`` statements.  For example,
were we to ``@load base/frameworks/logging``, Zeek would generate a
:file:`conn.log` and :file:`http.log` for us in the current working directory.
As mentioned above, including the appropriate ``@load`` statements is
not only good practice, but can also help to indicate which
functionalities are being used in a script.  Take a second to run the
script without the ``-b`` flag and check the output when all of Zeek's
functionality is applied to the trace file.

Data Types and Data Structures
==============================

Scope
-----

Before embarking on a exploration of Zeek's native data types and data
structures, it's important to have a good grasp of the different
levels of scope available in Zeek and the appropriate times to use them
within a script.  The declarations of variables in Zeek come in two
forms.  Variables can be declared with or without a definition in the
form ``SCOPE name: TYPE`` or ``SCOPE name = EXPRESSION`` respectively;
each of which produce the same result if ``EXPRESSION`` evaluates to the
same type as ``TYPE``.  The decision as to which type of declaration to
use is likely to be dictated by personal preference and readability.

.. literalinclude:: data_type_declaration.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

Global Variables
~~~~~~~~~~~~~~~~

A global variable is used when the state of variable needs to be
tracked, not surprisingly, globally.  While there are some caveats,
when a script declares a variable using the global scope, that script
is granting access to that variable from other scripts.  However, when
a script uses the ``module`` keyword to give the script a namespace,
more care must be given to the declaration of globals to ensure the
intended result.  When a global is declared in a script with a
namespace there are two possible outcomes.  First, the variable is
available only within the context of the namespace.  In this scenario,
other scripts within the same namespace will have access to the
variable declared while scripts using a different namespace or no
namespace altogether will not have access to the variable.
Alternatively, if a global variable is declared within an ``export { ... }``
block that variable is available to any other script through the
naming convention of ``<module name>::<variable name>``, i.e. the variable
needs to be "scoped" by the name of the module in which it was declared.

When the ``module`` keyword is used in a script, the variables declared
are said to be in that module's "namespace".  Where as a global variable
can be accessed by its name alone when it is not declared within a
module, a global variable declared within a module must be exported and
then accessed via ``<module name>::<variable name>``.

Constants
~~~~~~~~~

Zeek also makes use of constants, which are denoted by the ``const``
keyword.  Unlike globals, constants can only be set or altered at
parse time if the ``&redef`` attribute has been used.  Afterwards (in
runtime) the constants are unalterable.  In most cases, re-definable
constants are used in Zeek scripts as containers for configuration
options.  For example, the configuration option to log passwords
decrypted from HTTP streams is stored in
:zeek:see:`HTTP::default_capture_password` as shown in the stripped down
excerpt from :doc:`/scripts/base/protocols/http/main.zeek` below.

.. literalinclude:: http_main.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

Because the constant was declared with the ``&redef`` attribute, if we
needed to turn this option on globally, we could do so by adding the
following line to our ``site/local.zeek`` file before firing up Zeek.

.. literalinclude:: data_type_const_simple.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

While the idea of a re-definable constant might be odd, the constraint
that constants can only be altered at parse-time remains even with the
``&redef`` attribute.  In the code snippet below, a table of strings
indexed by ports is declared as a constant before two values are added
to the table through ``redef`` statements.  The table is then printed
in a :zeek:id:`zeek_init` event.  Were we to try to alter the table in
an event handler, Zeek would notify the user of an error and the script
would fail.

.. literalinclude:: data_type_const.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek -b data_type_const.zeek
   {
   [80/tcp] = WWW,
   [6666/tcp] = IRC
   }

Local Variables
~~~~~~~~~~~~~~~

Whereas globals and constants are widely available in scriptland
through various means, when a variable is defined with a local scope,
its availability is restricted to the body of the event or function in
which it was declared.  Local variables tend to be used for values
that are only needed within a specific scope and once the processing
of a script passes beyond that scope and no longer used, the variable
is deleted. Zeek maintains names of locals separately from globally
visible ones, an example of which is illustrated below.

.. literalinclude:: data_type_local.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

The script executes the event handler :zeek:id:`zeek_init` which in turn calls
the function ``add_two(i: count)`` with an argument of ``10``.  Once Zeek
enters the ``add_two`` function, it provisions a locally scoped
variable called ``added_two`` to hold the value of ``i+2``, in this
case, ``12``.  The ``add_two`` function then prints the value of the
``added_two`` variable and returns its value to the ``zeek_init`` event
handler.  At this point, the variable ``added_two`` has fallen out of
scope and no longer exists while the value ``12`` still in use and
stored in the locally scoped variable ``test``.  When Zeek finishes
processing the ``zeek_init`` function, the variable called ``test`` is
no longer in scope and, since there exist no other references to the
value ``12``, the value is also deleted.


Data Structures
---------------

It's difficult to talk about Zeek's data types in a practical manner
without first covering the data structures available in Zeek.  Some of
the more interesting characteristics of data types are revealed when
used inside of a data structure, but given that data structures are
made up of data types, it devolves rather quickly into a
"chicken-and-egg" problem.  As such, we'll introduce data types from
a bird's eye view before diving into data structures and from there a
more complete exploration of data types.

The table below shows the atomic types used in Zeek, of which the
first four should seem familiar if you have some scripting experience,
while the remaining six are less common in other languages. It should
come as no surprise that a scripting language for a Network Security
Monitoring platform has a fairly robust set of network-centric data
types and taking note of them here may well save you a late night of
reinventing the wheel.

.. list-table::
  :header-rows: 1

  * - Data Type
    - Description

  * - :zeek:see:`int`
    - 64 bit signed integer

  * - :zeek:see:`count`
    - 64 bit unsigned integer

  * - :zeek:see:`double`
    - double precision floating precision

  * - :zeek:see:`bool`
    - boolean (T/F)

  * - :zeek:see:`addr`
    - IP address, IPv4 and IPv6

  * - :zeek:see:`port`
    - transport layer port

  * - :zeek:see:`subnet`
    - CIDR subnet mask

  * - :zeek:see:`time`
    - absolute epoch time

  * - :zeek:see:`interval`
    - a time interval

  * - :zeek:see:`pattern`
    - regular expression

Sets
~~~~

Sets in Zeek are used to store unique elements of the same data
type.  In essence, you can think of them as "a unique set of integers"
or "a unique set of IP addresses".  While the declaration of a set may
differ based on the data type being collected, the set will always
contain unique elements and the elements in the set will always be of
the same data type.  Such requirements make the set data type perfect
for information that is already naturally unique such as ports or IP
addresses.  The code snippet below shows both an explicit and implicit
declaration of a locally scoped set.

.. literalinclude:: data_struct_set_declaration.zeek
   :caption:
   :language: zeek
   :linenos:
   :lines: 1-4,22
   :tab-width: 4

As you can see, sets are declared using the format ``SCOPE var_name:
set[TYPE]``.  Adding and removing elements in a set is achieved using
the ``add`` and ``delete`` statements.  Once you have elements inserted into
the set, it's likely that you'll need to either iterate over that set
or test for membership within the set, both of which are covered by
the ``in`` operator.  In the case of iterating over a set, combining the
``for`` statement and the ``in`` operator will allow you to sequentially
process each element of the set as seen below.

.. literalinclude:: data_struct_set_declaration.zeek
   :caption:
   :language: zeek
   :linenos:
   :lines: 17-21
   :lineno-start: 17
   :tab-width: 4

Here, the ``for`` statement loops over the contents of the set storing
each element in the temporary variable ``i``.  With each iteration of
the ``for`` loop, the next element is chosen.  Since sets are not an
ordered data type, you cannot guarantee the order of the elements as
the ``for`` loop processes.

To test for membership in a set the ``in`` statement can be combined
with an ``if`` statement to return a true or false value.  If the
exact element in the condition is already in the set, the condition
returns true and the body executes.  The ``in`` statement can also be
negated by the ``!`` operator to create the inverse of the condition.
While we could rewrite the corresponding line below as ``if ( !(
587/tcp in ssl_ports ))`` try to avoid using this construct; instead,
negate the in operator itself.  While the functionality is the same,
using the ``!in`` is more efficient as well as a more natural construct
which will aid in the readability of your script.

.. literalinclude:: data_struct_set_declaration.zeek
   :caption:
   :language: zeek
   :linenos:
   :lines: 13-15
   :lineno-start: 13
   :tab-width: 4

You can see the full script and its output below.

.. literalinclude:: data_struct_set_declaration.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek data_struct_set_declaration.zeek
   SSL Port: 22/tcp
   SSL Port: 443/tcp
   SSL Port: 587/tcp
   SSL Port: 993/tcp
   Non-SSL Port: 80/tcp
   Non-SSL Port: 25/tcp
   Non-SSL Port: 143/tcp
   Non-SSL Port: 23/tcp

Tables
~~~~~~

A table in Zeek is a mapping of a key to a value or yield.  While the
values don't have to be unique, each key in the table must be unique
to preserve a one-to-one mapping of keys to values.

.. literalinclude:: data_struct_table_declaration.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek data_struct_table_declaration.zeek
   Service Name:  SSH - Common Port: 22/tcp
   Service Name:  HTTPS - Common Port: 443/tcp
   Service Name:  SMTPS - Common Port: 587/tcp
   Service Name:  IMAPS - Common Port: 993/tcp

In this example,
we've compiled a table of SSL-enabled services and their common
ports.  The explicit declaration and constructor for the table are on
two different lines and lay out the data types of the keys (strings) and the
data types of the values (ports) and then fill in some sample key and
value pairs.  You can also use a table accessor to insert one
key-value pair into the table.  When using the ``in``
operator on a table, you are effectively working with the keys of the table.
In the case of an ``if`` statement, the ``in`` operator will check for
membership among the set of keys and return a true or false value.
The example shows how to check if ``SMTPS`` is not in the set
of keys for the ``ssl_services`` table and if the condition holds true,
we add the key-value pair to the table.  Finally, the example shows how
to use a ``for`` statement to iterate over each key currently in the table.

Simple examples aside, tables can become extremely complex as the keys
and values for the table become more intricate.  Tables can have keys
comprised of multiple data types and even a series of elements called
a "tuple".  The flexibility gained with the use of complex tables in
Zeek implies a cost in complexity for the person writing the scripts
but pays off in effectiveness given the power of Zeek as a network
security platform.

.. literalinclude:: data_struct_table_complex.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek -b data_struct_table_complex.zeek
   Harakiri was released in 1962 by Shochiku Eiga studios, directed by Masaki Kobayashi and starring Tatsuya Nakadai
   Goyokin was released in 1969 by Fuji studios, directed by Hideo Gosha and starring Tatsuya Nakadai
   Tasogare Seibei was released in 2002 by Eisei Gekijo studios, directed by Yoji Yamada and starring Hiroyuki Sanada
   Kiru was released in 1968 by Toho studios, directed by Kihachi Okamoto and starring Tatsuya Nakadai

This script shows a sample table of strings indexed by two
strings, a count, and a final string.  With a tuple acting as an
aggregate key, the order is important as a change in order would
result in a new key.  Here, we're using the table to track the
director, studio, year of release, and lead actor in a series of
samurai flicks.

In the case of the ``for`` statement above, iteration is done over all
parts of the key. When not all parts of a key are needed within the ``for``
loop's body, these can be ignored by using the blank identifier ``_``
instead of a variable.
It's important to note, however, that the structure of the key needs to
be reflected: All parts of the key need to be captured within the brackets
by a variable or the blank identifier.
As a special case, a single blank identifier allows to ignore the whole key.
In the previous example, we need squared brackets surrounding four temporary
variables to act as a collection for our iteration. While this
is a contrived example, we could easily have had keys containing IP addresses
(``addr``), ports (``port``) and even a ``string`` calculated as the result
of a reverse hostname lookup.

The example below continues with the ``samurai_flicks`` table and shows usage
of the blank identifier in combination with key-value iteration.
Using key-value iteration short-cuts the table access to lookup the value as
it provides the respective entry's value directly in addition to the key.

First, iteration is done by capturing the directors and movie names and
ignoring all other elements of the key. Second, the whole key is ignored
and only movie names used.

.. literalinclude:: data_struct_table_complex_blank_value.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek data_struct_table_complex_blank_value.zeek
   Kiru was directed by Kihachi Okamoto
   Harakiri was directed by Masaki Kobayashi
   Tasogare Seibei was directed by Yoji Yamada
   Goyokin was directed by Hideo Gosha
   Kiru is a movie
   Harakiri is a movie
   Tasogare Seibei is a movie
   Goyokin is a movie


Vectors
~~~~~~~

If you're coming to Zeek with a programming background, you may or may
not be familiar with a vector data type depending on your language of
choice.  On the surface, vectors perform much of the same
functionality as associative arrays with unsigned integers as their
indices. They are however more efficient than that and they allow for
ordered access. As such any time you need to sequentially store data of the
same type, in Zeek you should reach for a vector.  Vectors are a
collection of objects, all of which are of the same data type, to
which elements can be dynamically added or removed.  Since Vectors use
contiguous storage for their elements, the contents of a vector can be
accessed through a zero-indexed numerical offset.

The format for the declaration of a Vector follows the pattern of
other declarations, namely, ``SCOPE v: vector of T`` where ``v`` is
the name of your vector, and ``T`` is the data type of its members.
For example, the following snippet shows an explicit and implicit
declaration of two locally scoped vectors.  The script populates the
first vector by inserting values at the end; it does that by placing
the vector name between two vertical pipes to get the vector's current
length before printing the contents of both Vectors and their current
lengths.

.. literalinclude:: data_struct_vector_declaration.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek data_struct_vector_declaration.zeek
   contents of v1: [1, 2, 3, 4]
   length of v1: 4
   contents of v2: [1, 2, 3, 4]
   length of v2: 4

In a lot of cases, storing elements in a vector is simply a precursor
to then iterating over them.  Iterating over a vector is easy with the
``for`` keyword.  The sample below iterates over a vector of IP
addresses and for each IP address, masks that address with 18 bits.
The ``for`` keyword is used to generate a locally scoped variable
called ``i`` which will hold the index of the current element in the
vector. Using ``i`` as an index to addr_vector we can access the
current item in the vector with ``addr_vector[i]``.

.. literalinclude:: data_struct_vector_iter.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek -b data_struct_vector_iter.zeek
   1.2.0.0/18
   2.3.0.0/18
   3.4.0.0/18

Providing a value variable to the ``for`` loop allows skipping the extra
index operation. As the index variable is now is unused, the script below
uses ``_``, the blank identifier, to ignore it. This script is semantically
equivalent to the previous one, but does direct value iteration and therefore
potentially more performant for very large vectors.

.. literalinclude:: data_struct_vector_iter_value.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

Data Types Revisited
--------------------

addr
~~~~

The ``addr``, or address, data type manages to cover a surprisingly
large amount of ground while remaining succinct.  IPv4, IPv6 and even
hostname constants are included in the ``addr`` data type.  While IPv4
addresses use the default dotted quad formatting, IPv6 addresses use
the RFC 2373 defined notation with the addition of squared brackets
wrapping the entire address.  When you venture into hostname
constants, Zeek performs a little slight of hand for the benefit of the
user; a hostname constant is, in fact, a set of addresses.  Zeek will
issue a DNS request when it sees a hostname constant in use and return
a set whose elements are the answers to the DNS request.  For example,
if you were to use ``local google = www.google.com;`` you would end up
with a locally scoped ``set[addr]`` with elements that represent the
current set of round robin DNS entries for google.  At first blush,
this seems trivial, but it is yet another example of Zeek making the
life of the common Zeek scripter a little easier through abstraction
applied in a practical manner. (Note however that these IP addresses
will never get updated during Zeek's processing, so often this
mechanism most useful for addresses that are expected to remain
static.).

port
~~~~

Transport layer port numbers in Zeek are represented in the format of
``<unsigned integer>/<protocol name>``, e.g., ``22/tcp`` or
``53/udp``.  Zeek supports TCP(``/tcp``), UDP(``/udp``),
ICMP(``/icmp``) and UNKNOWN(``/unknown``) as protocol designations.
While ICMP doesn't have an actual port, Zeek supports the concept of
ICMP "ports" by using the ICMP message type and ICMP message code as
the source and destination port respectively.  Ports can be compared
for equality using the ``==`` or ``!=`` operators and can even be
compared for ordering.  Zeek gives the protocol designations the
following "order": ``unknown`` < ``tcp`` < ``udp`` < ``icmp``. For
example ``65535/tcp`` is smaller than ``0/udp``.

subnet
~~~~~~

Zeek has full support for CIDR notation subnets as a base data type.
There is no need to manage the IP and the subnet mask as two separate
entities when you can provide the same information in CIDR notation in
your scripts.  The following example below uses a Zeek script to
determine if a series of IP addresses are within a set of subnets
using a 20 bit subnet mask.

.. literalinclude:: data_type_subnets.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

Because this is a script that doesn't use any kind of network
analysis, we can handle the event :zeek:id:`zeek_init` which is always
generated by Zeek's core upon startup.  In the example script, two
locally scoped vectors are created to hold our lists of subnets and IP
addresses respectively.  Then, using a set of nested ``for`` loops, we
iterate over every subnet and every IP address and use an ``if``
statement to compare an IP address against a subnet using the ``in``
operator.  The ``in`` operator returns true if the IP address falls
within a given subnet based on the longest prefix match calculation.
For example, ``10.0.0.1 in 10.0.0.0/8`` would return true while
``192.168.2.1 in 192.168.1.0/24`` would return false.  When we run the
script, we get the output listing the IP address and the subnet in
which it belongs.

.. code-block:: console

   $ zeek data_type_subnets.zeek
   172.16.4.56 belongs to subnet 172.16.0.0/20
   172.16.47.254 belongs to subnet 172.16.32.0/20
   172.16.22.45 belongs to subnet 172.16.16.0/20
   172.16.1.1 belongs to subnet 172.16.0.0/20

time
~~~~

While there is currently no supported way to add a time constant in
Zeek, two built-in functions exist to make use of the ``time`` data
type.  Both :zeek:id:`network_time` and :zeek:id:`current_time` return a
``time`` data type but they each return a time based on different
criteria.  The ``current_time`` function returns what is called the
wall-clock time as defined by the operating system.  However,
``network_time`` returns the timestamp of the last packet processed
be it from a live data stream or saved packet capture.  Both functions
return the time in epoch seconds, meaning ``strftime`` must be used to
turn the output into human readable output.  The script below makes
use of the :zeek:id:`connection_established` event handler to generate text
every time a SYN/ACK packet is seen responding to a SYN packet as part
of a TCP handshake.  The text generated, is in the format of a
timestamp and an indication of who the originator and responder were.
We use the ``strftime`` format string of ``%Y-%m-%d %H:%M:%S`` to
produce a common date time formatted time stamp.

.. literalinclude:: data_type_time.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

When the script is executed we get an output showing the details of
established connections.

.. code-block:: console

   $ zeek -r wikipedia.trace data_type_time.zeek
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.118\x0a
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3\x0a
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3\x0a
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3\x0a
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3\x0a
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3\x0a
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3\x0a
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.2\x0a
   2011/06/18 19:03:09:  New connection established from 141.142.220.235 to 173.192.163.128\x0a

interval
~~~~~~~~

The ``interval`` data type is another area in Zeek where rational
application of abstraction makes perfect sense.  As a data type, the
``interval`` represents a relative time as denoted by a numeric constant
followed by a unit of time.  For example, 2.2 seconds would be
``2.2sec`` and thirty-one days would be represented by ``31days``.
Zeek supports ``usec``, ``msec``, ``sec``, ``min``, ``hr``, or ``day`` which represent
microseconds, milliseconds, seconds, minutes, hours, and days
respectively.  In fact, the ``interval`` data type allows for a surprising
amount of variation in its definitions.  There can be a space between
the numeric constant or they can be crammed together like a temporal
portmanteau.  The time unit can be either singular or plural.  All of
this adds up to to the fact that both ``42hrs`` and ``42 hr`` are
perfectly valid and logically equivalent in Zeek.  The point, however,
is to increase the readability and thus maintainability of a script.
Intervals can even be negated, allowing for ``- 10mins`` to represent
"ten minutes ago".

Intervals in Zeek can have mathematical operations performed against
them allowing the user to perform addition, subtraction,
multiplication, division, and comparison operations. As well, Zeek
returns an ``interval`` when differencing two ``time`` values using the ``-``
operator.  The script below amends the script started in the section
above to include a time delta value printed along with the connection
establishment report.

.. literalinclude:: data_type_interval.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

When we re-execute the script we see an additional line in the
output, displaying the time delta since the last fully established
connection.

.. code-block:: console

   $ zeek -r wikipedia.trace data_type_interval.zeek
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.118
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3
        Time since last connection: 132.0 msecs 97.0 usecs
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3
        Time since last connection: 177.0 usecs
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3
        Time since last connection: 2.0 msecs 177.0 usecs
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3
        Time since last connection: 33.0 msecs 898.0 usecs
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3
        Time since last connection: 35.0 usecs
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.3
        Time since last connection: 2.0 msecs 532.0 usecs
   2011/06/18 19:03:08:  New connection established from 141.142.220.118 to 208.80.152.2
        Time since last connection: 7.0 msecs 866.0 usecs
   2011/06/18 19:03:09:  New connection established from 141.142.220.235 to 173.192.163.128
        Time since last connection: 817.0 msecs 703.0 usecs


Pattern
~~~~~~~

Zeek has support for fast text searching operations using regular
expressions and even goes so far as to declare a native data type for
the patterns used in regular expressions.  A pattern constant is
created by enclosing text within the forward slash characters.  Zeek
supports syntax very similar to the Flex lexical analyzer syntax.  The
most common use of patterns in Zeek you are likely to come across is
embedded matching using the ``in`` operator.  Embedded matching
adheres to a strict format, requiring the regular expression or
pattern constant to be on the left side of the ``in`` operator and the
string against which it will be tested to be on the right.

.. literalinclude:: data_type_pattern_01.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

In the sample above, two local variables are declared to hold our
sample sentence and regular expression.  Our regular expression in
this case will return true if the string contains either the word
``quick`` or the word ``lazy``. The ``if`` statement in the script uses
embedded matching and the ``in`` operator to check for the existence
of the pattern within the string.  If the statement resolves to true,
:zeek:id:`split_string` is called to break the string into separate pieces.
:zeek:id:`split_string` takes a string and a pattern as its arguments and returns a
vector of strings.  Each element of the vector represents
segments before and after any matches against the pattern but
excluding the actual matches.  In this case, our pattern matches
twice resulting in a vector with three elements.

.. code-block:: console

   $ zeek data_type_pattern_01.zeek
   The
    brown fox jumps over the
    dog.

Patterns can also be used to compare strings using equality and
inequality operators through the ``==`` and ``!=`` operators
respectively. When used in this manner however, the string must match
entirely to resolve to true.  For example, the script below uses two
ternary conditional statements to illustrate the use of the ``==``
operator with patterns.  The output is altered based
on the result of the comparison between the pattern and the string.

.. literalinclude:: data_type_pattern_02.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek data_type_pattern_02.zeek
   equality and /^?(equal)$?/ are not equal
   equality and /^?(equality)$?/ are equal

Record Data Type
----------------

With Zeek's support for a wide array of data types and data structures,
an obvious extension is to include the ability to create custom
data types composed of atomic types and further data structures.  To
accomplish this, Zeek introduces the ``record`` type and the ``type``
keyword.  Similar to how you would define a new data structure in C
with the ``typedef`` and ``struct`` keywords, Zeek allows you to cobble
together new data types to suit the needs of your situation.

When combined with the ``type`` keyword, ``record`` can generate a
composite type.  We have, in fact, already encountered a complex
example of the ``record`` data type in the earlier sections, the
:zeek:type:`connection` record passed to many events. Another one,
:zeek:type:`Conn::Info`, which corresponds to the fields logged into
:file:`conn.log`, is shown by the excerpt below.

.. literalinclude:: data_type_record.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

Looking at the structure of the definition, a new collection of data
types is being defined as a type called ``Info``.  Since this type
definition is within the confines of an export block, what is defined
is, in fact, ``Conn::Info``.

The formatting for a declaration of a record type in Zeek includes the
descriptive name of the type being defined and the separate fields
that make up the record.  The individual fields that make up the new
record are not limited in type or number as long as the name for each
field is unique.

.. literalinclude:: data_struct_record_01.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek data_struct_record_01.zeek
   Service: dns(RFC1035)
     port: 53/udp
     port: 53/tcp
   Service: http(RFC2616)
     port: 8080/tcp
     port: 80/tcp

The sample above shows a simple type definition that includes a
string, a set of ports, and a count to define a service type.  Also
included is a function to print each field of a record in a formatted
fashion and a :zeek:id:`zeek_init` event handler to show some
functionality of working with records.  The definitions of the DNS and
HTTP services are both done in-line using squared brackets before being
passed to the ``print_service`` function.  The ``print_service``
function makes use of the ``$`` dereference operator to access the
fields within the newly defined Service record type.

As you saw in the definition for the ``Conn::Info`` record, other
records are even valid as fields within another record.  We can extend
the example above to include another record that contains a Service
record.

.. literalinclude:: data_struct_record_02.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek data_struct_record_02.zeek
   System: morlock
     Service: http(RFC2616)
       port: 8080/tcp
       port: 80/tcp
     Service: dns(RFC1035)
       port: 53/udp
       port: 53/tcp

The example above includes a second record type in which a field is
used as the data type for a set.  Records can be repeatedly nested
within other records, their fields reachable through repeated chains
of the ``$`` dereference operator.

It's also common to see a ``type`` used to simply alias a data
structure to a more descriptive name.  The example below shows an
example of this from Zeek's own type definitions file.

.. code-block:: zeek
   :caption: init-bare.zeek

   type string_array: table[count] of string;
   type string_set: set[string];
   type addr_set: set[addr];

The three lines above alias a type of data structure to a descriptive
name.  Functionally, the operations are the same, however, each of the
types above are named such that their function is instantly
identifiable.  This is another place in Zeek scripting where
consideration can lead to better readability of your code and thus
easier maintainability in the future.


Custom Logging
==============

Armed with a decent understanding of the data types and data
structures in Zeek, exploring the various frameworks available is a
much more rewarding effort.  The framework with which most users are
likely to have the most interaction is the Logging Framework.
Designed in such a way to so as to abstract much of the process of
creating a file and appending ordered and organized data into it, the
Logging Framework makes use of some potentially unfamiliar
nomenclature.  Specifically, Log Streams, Filters and Writers are
simply abstractions of the processes required to manage a high rate of
incoming logs while maintaining full operability.  If you've seen Zeek
employed in an environment with a large number of connections, you
know that logs are produced incredibly quickly; the ability to process
a large set of data and write it to disk is due to the design of the
Logging Framework.

Data is written to a Log Stream based on decision making processes in
Zeek's scriptland.  Log Streams correspond to a single log as defined
by the set of name/value pairs that make up its fields.  That data can
then be filtered, modified, or redirected with Logging Filters which,
by default, are set to log everything.  Filters can be used to break
log files into subsets or duplicate that information to another
output.  The final output of the data is defined by the writer.  Zeek's
default writer is simple tab separated ASCII files but Zeek also
includes support for `DataSeries <https://github.com/dataseries>`_
and `Elasticsearch <http://www.elasticsearch.org>`_ outputs as well as
additional writers currently in development.  While these new terms
and ideas may give the impression that the Logging Framework is
difficult to work with, the actual learning curve is, in actuality,
not very steep at all.  The abstraction built into the Logging
Framework makes it such that a vast majority of scripts needs not go
past the basics.  In effect, writing to a log file is as simple as
defining the format of your data, letting Zeek know that you wish to
create a new log, and then calling the :zeek:id:`Log::write` method to
output log records.

The Logging Framework is an area in Zeek where, the more you see it
used and the more you use it yourself, the more second nature the
boilerplate parts of the code will become.  As such, let's work
through a contrived example of simply logging the digits 1 through 10
and their corresponding factorial to the default ASCII log writer.
It's always best to work through the problem once, simulating the
desired output with ``print`` and ``fmt`` before attempting to dive
into the Logging Framework.

.. literalinclude:: framework_logging_factorial_01.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

.. code-block:: console

   $ zeek framework_logging_factorial_01.zeek
   1
   2
   6
   24
   120
   720
   5040
   40320
   362880
   3628800

This script defines a factorial function to recursively calculate the
factorial of a unsigned integer passed as an argument to the function.  Using
``print`` and  :zeek:id:`fmt` we can ensure that Zeek can perform these
calculations correctly as well get an idea of the answers ourselves.

The output of the script aligns with what we expect so now it's time
to integrate the Logging Framework.

.. literalinclude:: framework_logging_factorial_02.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

As mentioned above we have to perform a few steps before we can
issue the :zeek:id:`Log::write` method and produce a logfile.
As we are working within a namespace and informing an outside
entity of workings and data internal to the namespace, we use
an ``export`` block.  First we need to inform Zeek
that we are going to be adding another Log Stream by adding a value to
the :zeek:type:`Log::ID` enumerable.  In this script, we append the
value ``LOG`` to the ``Log::ID`` enumerable, however due to this being in
an export block the value appended to ``Log::ID`` is actually
``Factor::LOG``.  Next, we define the fields
that make up the data of our logs and dictate its format.  This script
defines a new record datatype called ``Info`` (actually,
``Factor::Info``) with two fields, both unsigned integers. Each of the
fields in the ``Factor::Info`` record type include the ``&log``
attribute, indicating that these fields should be passed to the
Logging Framework when ``Log::write`` is called.
Any record fields without the ``&log`` attribute are ignored by the
Logging Framework. The next step is to create the logging
stream with :zeek:id:`Log::create_stream` which takes a ``Log::ID`` and a
record as its arguments.  In this example, we call the
``Log::create_stream`` method and pass ``Factor::LOG`` and the
``Factor::Info`` record as arguments. From here on out, if we issue
the ``Log::write`` command with the correct ``Log::ID`` and a properly
formatted ``Factor::Info`` record, a log entry will be generated.

Now, if we run this script, instead of generating
logging information to stdout, no output is created.  Instead the
output is all in :file:`factor.log`, properly formatted and organized.

.. code-block:: console

   $ zeek framework_logging_factorial_02.zeek
   $ cat factor.log
   #separator \x09
   #set_separator    ,
   #empty_field      (empty)
   #unset_field      -
   #path     factor
   #open     2018-12-14-21-47-18
   #fields   num     factorial_num
   #types    count   count
   1 1
   2 2
   3 6
   4 24
   5 120
   6 720
   7 5040
   8 40320
   9 362880
   10        3628800
   #close    2018-12-14-21-47-18

While the previous example is a simplistic one, it serves to
demonstrate the small pieces of script code that need to be in place in
order to generate logs.  For example, it's common to call
``Log::create_stream`` in :zeek:id:`zeek_init` and while in a live
example, determining when to call ``Log::write`` would likely be
done in an event handler, in this case we use :zeek:id:`zeek_done` .

If you've already spent time with a deployment of Zeek, you've likely
had the opportunity to view, search through, or manipulate the logs
produced by the Logging Framework.  The log output from a default
installation of Zeek is substantial to say the least, however, there
are times in which the way the Logging Framework by default isn't
ideal for the situation.  This can range from needing to log more or
less data with each call to ``Log::write`` or even the need to split
log files based on arbitrary logic.  In the later case, Filters come
into play along with the Logging Framework.  Filters grant a level of
customization to Zeek's scriptland, allowing the script writer to
include or exclude fields in the log and even make alterations to the
path of the file in which the logs are being placed.  Each stream,
when created, is given a default filter called, not surprisingly,
``default``.  When using the ``default`` filter, every key value pair
with the ``&log`` attribute is written to a single file.  For the
example we've been using, let's extend it so as to write any factorial
which is a factor of 5 to an alternate file, while writing the
remaining logs to :file:`factor.log`.

.. literalinclude:: framework_logging_factorial_03.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

To dynamically alter the file in which a stream writes its logs, a
filter can specify a function that returns a string to be used as the
filename for the current call to ``Log::write``. The definition for
this function has to take as its parameters a ``Log::ID`` called id, a
string called ``path`` and the appropriate record type for the logs called
``rec``.  You can see the definition of ``mod5`` used in this example
conforms to that requirement.  The function simply returns
``factor-mod5`` if the factorial is divisible evenly by 5, otherwise, it
returns ``factor-non5``.  In the additional ``zeek_init`` event
handler, we define a locally scoped ``Log::Filter`` and assign it a
record that defines the ``name`` and ``path_func`` fields.  We then
call ``Log::add_filter`` to add the filter to the ``Factor::LOG``
``Log::ID`` and call ``Log::remove_filter`` to remove the ``default``
filter for ``Factor::LOG``.  Had we not removed the ``default`` filter,
we'd have ended up with three log files: :file:`factor-mod5.log` with all the
factorials that are a factors of 5, :file:`factor-non5.log` with the
factorials that are not factors of 5, and :file:`factor.log` which would have
included all factorials.

.. code-block:: console

   $ zeek framework_logging_factorial_03.zeek
   $ cat factor-mod5.log
   #separator \x09
   #set_separator    ,
   #empty_field      (empty)
   #unset_field      -
   #path     factor-mod5
   #open     2018-12-14-21-47-18
   #fields   num     factorial_num
   #types    count   count
   5 120
   6 720
   7 5040
   8 40320
   9 362880
   10        3628800
   #close    2018-12-14-21-47-1

The ability of Zeek to generate easily customizable and extensible logs
which remain easily parsable is a big part of the reason Zeek has
gained a large measure of respect.  In fact, it's difficult at times
to think of something that Zeek doesn't log and as such, it is often
advantageous for analysts and systems architects to instead hook into
the logging framework to be able to perform custom actions based upon
the data being sent to the Logging Frame.  To that end, every default
log stream in Zeek generates a custom event that can be handled by
anyone wishing to act upon the data being sent to the stream.  By
convention these events are usually in the format ``log_x`` where x is
the name of the logging stream; as such the event raised for every log
sent to the Logging Framework by the HTTP parser would be ``log_http``.
Instead of using an external script to parse the :file:`http.log` file and
do post-processing for each entry, this can be done in real time inside
Zeek by defining an event handler for the ``log_http`` event.

Telling Zeek to raise an event in your own Logging stream is as simple
as exporting that event name and then adding that event in the call to
``Log::create_stream``.  Going back to our simple example of logging
the factorial of an integer, we add ``log_factor`` to the ``export``
block and define the value to be passed to it, in this case the
``Factor::Info`` record.  We then list the ``log_factor`` function as
the ``$ev`` field in the call to ``Log::create_stream``

.. literalinclude:: framework_logging_factorial_04.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4


Raising Notices
===============

While Zeek's Logging Framework provides an easy and systematic way to
generate logs, there still exists a need to indicate when a specific
behavior has been detected and a method to allow that detection to
come to someone's attention.  To that end, the Notice Framework is in
place to allow script writers a codified means through which they can
raise a notice, as well as a system through which an operator can
opt-in to receive the notice.  Zeek holds to the philosophy that it is
up to the individual operator to indicate the behaviors in which they
are interested and as such Zeek ships with a large number of policy
scripts which detect behavior that may be of interest but it does not
presume to guess as to which behaviors are "action-able".  In effect,
Zeek works to separate the act of detection and the responsibility of
reporting.  With the Notice Framework it's simple to raise a notice
for any behavior that is detected.

To raise a notice in Zeek, you only need to indicate to Zeek that you
are provide a specific :zeek:type:`Notice::Type` by exporting it and then
make a call to :zeek:id:`NOTICE` supplying it with an appropriate
:zeek:type:`Notice::Info` record.  Often times the call to ``NOTICE``
includes just the ``Notice::Type``, and a concise message.  There are
however, significantly more options available when raising notices as
seen in the definition of :zeek:type:`Notice::Info`.  The only field in
``Notice::Info`` whose
attributes make it a required field is the ``note`` field.  Still,
good manners are always important and including a concise message in
``$msg`` and, where necessary, the contents of the connection record
in ``$conn`` along with the ``Notice::Type`` tend to comprise the
minimum of information required for an notice to be considered useful.
If the ``$conn`` variable is supplied the Notice Framework will
auto-populate the ``$id`` and ``$src`` fields as well.  Other fields
that are commonly included, ``$identifier`` and ``$suppress_for`` are
built around the automated suppression feature of the Notice Framework
which we will cover shortly.

One of the default policy scripts raises a notice when an SSH login
has been heuristically detected and the originating hostname is one
that would raise suspicion.  Effectively, the script attempts to
define a list of hosts from which you would never want to see SSH
traffic originating, like DNS servers, mail servers, etc.  To
accomplish this, the script adheres to the separation of detection
and reporting by detecting a behavior and raising a notice.  Whether
or not that notice is acted upon is decided by the local Notice
Policy, but the script attempts to supply as much information as
possible while staying concise.

.. code-block:: zeek
   :caption: scripts/policy/protocols/ssh/interesting-hostnames.zeek

   ##! This script will generate a notice if an apparent SSH login originates
   ##! or heads to a host with a reverse hostname that looks suspicious.  By
   ##! default, the regular expression to match "interesting" hostnames includes
   ##! names that are typically used for infrastructure hosts like nameservers,
   ##! mail servers, web servers and ftp servers.

   @load base/frameworks/notice

   module SSH;

   export {
       redef enum Notice::Type += {
           ## Generated if a login originates or responds with a host where
           ## the reverse hostname lookup resolves to a name matched by the
           ## :zeek:id:`SSH::interesting_hostnames` regular expression.
           Interesting_Hostname_Login,
       };

       ## Strange/bad host names to see successful SSH logins from or to.
       option interesting_hostnames =
               /^d?ns[0-9]*\./ |
               /^smtp[0-9]*\./ |
               /^mail[0-9]*\./ |
               /^pop[0-9]*\./  |
               /^imap[0-9]*\./ |
               /^www[0-9]*\./  |
               /^ftp[0-9]*\./;
   }

   function check_ssh_hostname(id: conn_id, uid: string, host: addr)
       {
       when ( local hostname = lookup_addr(host) )
           {
           if ( interesting_hostnames in hostname )
               {
               NOTICE([$note=Interesting_Hostname_Login,
                       $msg=fmt("Possible SSH login involving a %s %s with an interesting hostname.",
                                Site::is_local_addr(host) ? "local" : "remote",
                                host == id$orig_h ? "client" : "server"),
                       $sub=hostname, $id=id, $uid=uid]);
               }
           }
       }

   event ssh_auth_successful(c: connection, auth_method_none: bool)
       {
       for ( host in set(c$id$orig_h, c$id$resp_h) )
           {
           check_ssh_hostname(c$id, c$uid, host);
           }
       }

While much of the script relates to the actual detection, the parts
specific to the Notice Framework are actually quite interesting in
themselves.  The script's ``export`` block adds the value
``SSH::Interesting_Hostname_Login`` to the enumerable constant
``Notice::Type`` to indicate to the Zeek core that a new type of notice
is being defined.  The script then calls ``NOTICE`` and defines the
``$note``, ``$msg``, ``$sub``, ``id``, and ``$uid`` fields of the
:zeek:type:`Notice::Info` record. (More commonly, one would set
``$conn`` instead, however this script avoids using the connection
record inside the when-statement for performance reasons.)
There are two ternary if
statements that modify the ``$msg`` text depending on whether the
host is a local address and whether it is the client or the server.
This use of :zeek:id:`fmt` and ternary operators is a concise way to
lend readability to the notices that are generated without the need
for branching ``if`` statements that each raise a specific notice.

The opt-in system for notices is managed through writing
:zeek:id:`Notice::policy` hooks.  A ``Notice::policy`` hook takes as
its argument a ``Notice::Info`` record which will hold the same
information your script provided in its call to ``NOTICE``.  With
access to the ``Notice::Info`` record for a specific notice you can
include logic such as in statements in the body of your hook to alter
the policy for handling notices on your system.  In Zeek, hooks are
akin to a mix of functions and event handlers: like functions, calls
to them are synchronous (i.e., run to completion and return); but like
events, they can have multiple bodies which will all execute. For
defining a notice policy, you define a hook and Zeek will take care of
passing in the ``Notice::Info`` record.  The simplest kind of
``Notice::policy`` hooks simply check the value of ``$note`` in the
``Notice::Info`` record being passed into the hook and performing an
action based on the answer.  The hook below adds the
:zeek:enum:`Notice::ACTION_EMAIL` action for the
``SSH::Interesting_Hostname_Login`` notice raised in the
:doc:`/scripts/policy/protocols/ssh/interesting-hostnames.zeek` script.

.. literalinclude:: framework_notice_hook_01.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

In the example above we've added ``Notice::ACTION_EMAIL`` to the
``n$actions`` set.  This set, defined in the Notice Framework scripts,
can only have entries from the :zeek:type:`Notice::Action` type, which is
itself an enumerable that defines the values shown in the table below
along with their corresponding meanings.  The
:zeek:enum:`Notice::ACTION_LOG` action writes the notice to the
``Notice::LOG`` logging stream which, in the default configuration,
will write each notice to the :file:`notice.log` file and take no further
action.  The :zeek:enum:`Notice::ACTION_EMAIL` action will send an email
to the address or addresses defined in the :zeek:id:`Notice::mail_dest`
variable with the particulars of the notice as the body of the email.
The last action, :zeek:enum:`Notice::ACTION_ALARM` sends the notice to
the :zeek:enum:`Notice::ALARM_LOG` logging stream which is then rotated
hourly and its contents emailed in readable ASCII to the addresses in
``Notice::mail_dest``.

.. list-table::

  * - :zeek:see:`Notice::ACTION_NONE`
    - Take no action
  * - :zeek:see:`Notice::ACTION_LOG`
    - Send the notice to the Notice::LOG logging stream.
  * - :zeek:see:`Notice::ACTION_EMAIL`
    - Send an email with the notice in the body.
  * - :zeek:see:`Notice::ACTION_ALARM`
    - Send the notice to the Notice::Alarm_LOG stream.

While actions like the ``Notice::ACTION_EMAIL`` action have appeal for
quick alerts and response, a caveat of its use is to make sure the
notices configured with this action also have a suppression.  A
suppression is a means through which notices can be ignored after they
are initially raised if the author of the script has set an
identifier.  An identifier is a unique string of information collected
from the connection relative to the behavior that has been observed by
Zeek.

.. code-block:: zeek
   :caption: scripts/policy/protocols/ssl/expiring-certs.zeek

   NOTICE([$note=Certificate_Expires_Soon,
           $msg=fmt("Certificate %s is going to expire at %T", cert$subject, cert$not_valid_after),
           $conn=c, $suppress_for=1day,
           $identifier=cat(c$id$resp_h, c$id$resp_p, hash),
           $fuid=fuid]);

In the :doc:`/scripts/policy/protocols/ssl/expiring-certs.zeek` script
which identifies when SSL certificates are set to expire and raises
notices when it crosses a predefined threshold, the call to
``NOTICE`` above also sets the ``$identifier`` entry by concatenating
the responder IP, port, and the hash of the certificate.  The
selection of responder IP, port and certificate hash fits perfectly
into an appropriate identifier as it creates a unique identifier with
which the suppression can be matched. Were we to take out any of the
entities used for the identifier, for example the certificate hash, we
could be setting our suppression too broadly, causing an analyst to
miss a notice that should have been raised.  Depending on the
available data for the identifier, it can be useful to set the
``$suppress_for`` variable as well.  The ``expiring-certs.zeek`` script
sets ``$suppress_for`` to ``1day``, telling the Notice Framework to
suppress the notice for 24 hours after the first notice is raised.
Once that time limit has passed, another notice can be raised which
will again set the ``1day`` suppression time.  Suppressing for a
specific amount of time has benefits beyond simply not filling up an
analyst's email inbox; keeping the notice alerts timely and succinct
helps avoid a case where an analyst might see the notice and, due to
over exposure, ignore it.

The ``$suppress_for`` variable can also be altered in a
``Notice::policy`` hook, allowing a deployment to better suit the
environment in which it is be run.  Using the example of
``expiring-certs.zeek``, we can write a ``Notice::policy`` hook for
``SSL::Certificate_Expires_Soon`` to configure the ``$suppress_for``
variable to a shorter time.

.. literalinclude:: framework_notice_hook_suppression_01.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

While ``Notice::policy`` hooks allow you to build custom
predicate-based policies for a deployment, there are bound to be times
where you don't require the full expressiveness that a hook allows.
In short, there will be notice policy considerations where a broad
decision can be made based on the ``Notice::Type`` alone.  To
facilitate these types of decisions, the Notice Framework supports
Notice Policy shortcuts.  These shortcuts are implemented through the
means of a group of data structures that map specific, predefined
details and actions to the effective name of a notice.  Primarily
implemented as a set or table of enumerables of :zeek:type:`Notice::Type`,
Notice Policy shortcuts can be placed as a single directive in your
``local.zeek`` file as a concise readable configuration.  As these
variables are all constants, it bears mentioning that these variables
are all set at parse-time before Zeek is fully up and running and not
set dynamically.

+------------------------------------+-----------------------------------------------------+-------------------------------------+
| Name                               | Description                                         | Data Type                           |
+====================================+=====================================================+=====================================+
| Notice::ignored_types              | Ignore the Notice::Type entirely                    | set[Notice::Type]                   |
+------------------------------------+-----------------------------------------------------+-------------------------------------+
| Notice::emailed_types              | Set Notice::ACTION_EMAIL to this Notice::Type       | set[Notice::Type]                   |
+------------------------------------+-----------------------------------------------------+-------------------------------------+
| Notice::alarmed_types              | Set Notice::ACTION_ALARM to this Notice::Type       | set[Notice::Type]                   |
+------------------------------------+-----------------------------------------------------+-------------------------------------+
| Notice::not_suppressed_types       | Remove suppression from this Notice::Type           | set[Notice::Type]                   |
+------------------------------------+-----------------------------------------------------+-------------------------------------+
| Notice::type_suppression_intervals | Alter the $suppress_for value for this Notice::Type | table[Notice::Type] of interval     |
+------------------------------------+-----------------------------------------------------+-------------------------------------+



The table above details the five Notice Policy shortcuts, their
meaning and the data type used to implement them.  With the exception
of ``Notice::type_suppression_intervals`` a ``set`` data type is
employed to hold the ``Notice::Type`` of the notice upon which a
shortcut should applied.  The first three shortcuts are fairly self
explanatory, applying an action to the ``Notice::Type`` elements in
the set, while the latter two shortcuts alter details of the
suppression being applied to the Notice.  The shortcut
``Notice::not_suppressed_types`` can be used to remove the configured
suppression from a notice while ``Notice::type_suppression_intervals``
can be used to alter the suppression interval defined by $suppress_for
in the call to ``NOTICE``.

.. literalinclude:: framework_notice_shortcuts_01.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

The Notice Policy shortcut above adds the ``Notice::Type`` of
``SSH::Interesting_Hostname_Login`` to the
``Notice::emailed_types`` set while the shortcut below alters the length
of time for which those notices will be suppressed.

.. literalinclude:: framework_notice_shortcuts_02.zeek
   :caption:
   :language: zeek
   :linenos:
   :tab-width: 4

*****************************
 HTTP Entity Patterns Script
*****************************

For this tutorial, we will build a script which searches for certain
patterns in HTTP entities. These will be in a list of “interesting
patterns” that the user can provide. Then, we will augment the HTTP log
with the number of matches. This particular script will be very slow, so
not a production-level analysis, but it will help show many of the core
principles of Zeek scripts and augmenting logs.

Zeek’s scripting language is event based. As network traffic is
processed, events get triggered. When making a script, the author has to
decide what to react to. For this case, we care about HTTP “entities” -
the body of the request or response.

We can find the corresponding event by looking through the HTTP protocol
documentation. TODO: I really have troubles explaining how to find the
correct event. I would imagine people have troubles finding the right
event so… yeah.

In this case, we care about HTTP entities, so the ``http_entity_data``
event is promising. This event can provide a ``string`` containing the
data from the entity. Its signature is:

.. code:: zeek

   event http_entity_data(c: connection, is_orig: bool, length: count, data: string)

Given this, we can see how a package might look. Users can use the
``print`` statement in order to print a given object. In this case,
let’s print the data directly:

   .. code:: zeek

      # test.zeek

      event http_entity_data(c: connection, is_orig: bool, length: count, data: string) {
        print data;
      }

NOTE: This (and many other programming tutorials) use printing in order
to demonstrate functionality. However, it’s important to note that this
is almost entirely a tool for debugging. Production-grade scripts should
use other tools such as logging or the notice framework in order to
convey information.

Save that in a file ``test.zeek``. Then, open another terminal in the
container (TODO: Explain how to have 2 sessions in Docker). We will run
Zeek in the first:

   .. code:: console

      root@zeek-tutorial:/opt $ zeek -C -i eth0 test.zeek
      listening on eth0

and then ``curl`` in the other:

   .. code:: console

      root@zeek-tutorial:/opt $ curl example.com

You should see *both* windows with the HTML content. One immediately
noticeable difference is that many characters are replaced with hex
codes in the Zeek output. Another is noticeable with large web pages, or
by `redef`-ing a variable.

Try the same thing, except change the Zeek invocation to include a
redefinition for ``http_entity_data_delivery_size``:

   .. code:: console

      root@zeek-tutorial:/opt $ zeek -C -i eth0 test.zeek http_entity_data_delivery_size=10
      listening on eth0

and in the other terminal:

   .. code:: console

      root@zeek-tutorial:/opt $ curl example.com

Zeek’s output will look different - namely, every 10 bytes, there should
be a newline. This event gets called in batches for large files. If
we’re looking for a certain pattern, we have to reassemble the complete
data, just in case the pattern spans multiple lines. That will be the
first step.

Reassembling HTTP Entities
==========================

Thankfully, Zeek provides a convenient way to store state between event
calls within the same connection: The connection record!

Most (TODO: All?) protocols append a record to the connection record in
order to store its state. For HTTP (TODO: all?) protocols, this record
is called ``State``. Not only does this store information that the
analyzer uses, we can also append our own fields to it for various
purposes. We will use the ``redef`` keyword for this.

Above the ``http_entity_data`` event, let’s add a string to keep track
of the entity data we’ve seen so far:

   .. code:: zeek

      redef record HTTP::State += {
          entity: string &default="";
      };

This statement will take the ``HTTP::State`` record mentioned before and
add a field to it. When fields get added, they must have either
``&default`` (which specifies the default value) or ``&optional`` (which
means you don’t need to initialize the field if you don’t want to). In
this case, we have a simple default that we can use to “build up” the
entity, so we use default. The default ``entity`` value gets created
whenever the ``HTTP::State`` record is created by the HTTP analyzer. The
HTTP analyzer doesn’t need to know that we just appended a field to its
record.

Then, we can modify the event handler to add the data to this for each
event:

   .. code:: zeek

      # test.zeek

      event http_entity_data(c: connection, is_orig: bool, length: count, data: string) {
          c$http_state$entity += data;
          print c$http_state$entity;
      }

Inside the event, we have two new statements. The first is where most of
the magic happens. For Zeek scripting, the ``$`` separates field values.
This is often ``.`` in other languages (like ``my_class.my_field``). We
then use the ``+=`` operator to concatenate the ``data`` string to
what’s in that field.

The other key here is that ``connection`` object. The connection record
(that is, the first argument to the event) carries around state for the
connection. Different protocols will use the same ``redef`` trick, but
for the ``connection`` record, in order to carry around its data. You
can see which fields an analyzer adds to the ``connection`` object in
the “redefinitions” section in the script’s documentation - here for
HTTP. You can see from that section that the HTTP analyzer adds a
variable ``http_state`` with type ``HTTP::State`` to the ``connection``
record - thus, we can use it!

Before we use it, since ``c$http_state`` is an optional field, it could
be necessary to ensure that the ``c$http_state`` field exists before
using it. If you use an optional field without it being present, that
would be an error:

   .. code:: console

      expression error in ./test.zeek, line 7: field value missing (c$http_state)

Therefore, we should wrap anything that uses ``http_state`` with a field
value existence check with ``?$``:

   .. code:: zeek

      event http_entity_data(c: connection, is_orig: bool, length: count, data: string) {
          if ( c?$http_state ) {
              c$http_state$entity += data;
              print c$http$entity;
          }
      }

This should get exactly the same results as before. If you want to test
it, you can use ``delete c$http_state;`` before the ``if`` statement in
order to make sure it’s not set when it gets to that point, even though
it always should be.

This prints the information as it is getting collected. Instead, it
should only print once at the end. For this, we can use the
``http_end_entity`` event. Remove the `print` that is in
``http_entity_data`` and move it to the ``http_end_entity`` event:

   .. code:: zeek

      event http_end_entity(c: connection, is_orig: bool, length: count, data: string) {
          if ( c?$http_state ) {
              print c$http_state$entity;
          }
      }

TODO: Should we also reset $entity here?

Now, it will only print once - at the end of an entity.

TODO: Can entities be nested? I think not but entities.zeek deals with a
depth and I really don’t want to. :)

There is one more caveat. This gives theoretically unbounded state
growth, as `entity` has no upper bound. We should introduce an upper
bound that users can configure. This is easy with redefineable options!

First, we declare the option at the top of the file in an ``export``
block:

   .. code:: zeek

      export {
        option max_reassembled_entity_size: int = 10000 &redef;
      }

.. note::

   Zeek has two main types for numbers: ``int`` (if it can be negative)
   and ``count`` (if it cannot be negative). The
   ``max_reassembled_entity_size`` is an ``int`` - but it should not be
   negative! This makes Zeek understand that the *result* of any
   calculations using this number may also be negative. Thus, later,
   when we subtract another ``count``, this number may be negative. If
   it were a ``count``, there is potential for that result to
   "underflow" and become a very large number instead - which would be a
   bug.

   Also note, options can be changed, but only through specific
   mechanisms. See the (TODO: link) option declaration documentation for
   more information.

Then, we want to reach exactly that entity size, but never exceed it.
You can use ``|...|`` around a string to get its size, like
``|c$http_state$entity|`` will get the length of the string in that
field. You can do the same to get the size of most containers, like a
vector. If we subtract it from ``max_reassembled_entity_size``, that
should be the remaining length:

   .. code:: zeek

      local remaining_available = max_reassembled_entity_size - |c$http_state$entity|;
      if (remaining_available <= 0) return;

This will go inside the ``if`` block from before, but shown here for
demonstration purposes.

The ``local`` keyword just means that ``remaining_available`` will not
be usable outside of the current scope - which will be the ``if`` block.

Next, we will just decide how much of ``data`` to add depending on
``length``:

   .. code:: zeek

      if (length <= remaining_available)
        c$http_state$entity += data;
      else
        c$http_state$entity += data[:remaining_available];

Where the subscript operator (in ``data[:remaining_available]``) allows
extracting just the substring if we only want part of the provided data.

The full script at this point is here for your convenience. This is also
available in the Docker image in
``/opt/scripting-tutorial/01-http-entities.zeek``:

   .. code:: zeek

      export {
          option max_reassembled_entity_size = 10000 &redef;
      }

      redef record HTTP::State += {
          entity: string &default="";
      };

      event http_entity_data(c: connection, is_orig: bool, length: count, data: string) {
          if ( c?$http_state ) {
              local remaining_available = max_reassembled_entity_size - |c$http_state$entity|;
              if (remaining_available <= 0) return;
              if (length < remaining_available)
                  c$http_state$entity += data;
              else
                  c$http_state$entity += data[:remaining_available];
          }
      }

      event http_end_entity(c: connection, is_orig: bool) {
          if (c?$http_state) {
              print c$http_state$entity;
          }
      }

Searching for Patterns
======================

Now, we have all of the data in a given entity stored in
c$http_state$entity. We may want to examine that reassembled data for
certain patterns. Then, just for completeness, we can log how many of
those patterns matched entities in the HTTP connection.

Patterns in Zeek are built on regular expressions - they can be used to
find matches within a larger string. They are enclosed by forward
slashes (``/``). You can read more about them here.

We want to find specific strings within the HTTP entity, so this is
perfect. First, let’s see how you would search for a pattern in HTTP
traffic. In ``http_end_entity`` we print the entity, let’s change that
to print if some pattern matched:

   .. code:: zeek

      event http_end_entity(c: connection, is_orig: bool) {
          if (c?$http_state) {
              print /Will not match!/ in c$http_state$entity;
          }
      }

Running this on the quickstart pcap will yield no matches:

   ..
      code: console

      root@zeek-tutorial:/opt $ zeek -Cr traces/quickstart.pcap scripting-tutorial/01-http-entities.zeek
      F
      F
      F
      F

Note that in Zeek, true and false are represented by single-character
``T`` and ``F`` respectively.

We can change this script to actually match, say with a ``<body>`` tag:

   ..
      code: console

      root@zeek-tutorial:/opt $ zeek -Cr traces/quickstart.pcap scripting-tutorial/01-http-entities.zeek
      F
      T
      F
      T

TODO: Include first characters and explain that some are empty

At this point, we need:

A list of user-provided patterns to match How many of those patterns
matched the entity content

The first is easy, it’s similar to the ``max_reassembled_entity_size``
from before. Just put a vector in the export block with ``&redef``:

   .. code:: zeek

      const http_entity_patterns: vector of pattern = {/Will not match!/, /<body>/, /301 Moved Permanently/} &redef;

Then part 2 can be done in a function that takes the content and returns
the number of patterns that matched. Functions are defined similar to
events, just with the ``function`` keyword. These have to be explicitly
called in your Zeek scripts. Here is the function signature:

   .. code:: zeek

      function num_entity_pattern_matches(state: HTTP::State): count {

This function takes in a single HTTP::State as a parameter and returns a
count - easy enough. One important point is that this function’s
parameter is not the entity itself, but the HTTP state. This is because
atomic values (like counts, addresses, and strings) are passed by
*value* in Zeek. That means if the entity was passed in as a string, it
would get copied, which could be very expensive. Instead, we pass in the
HTTP state. Types like records or tables are passed by *reference*, so
no copy is necessary.

Now, its implementation simply loops through the patterns in
http_entity_patterns and counts the matches:

   .. code:: zeek

      function num_entity_pattern_matches(state: HTTP::State): count {
          local num_matches = 0;
          for (_, pat in http_entity_patterns) {
              if (pat in state$entity)
                  num_matches += 1;
          }

          return num_matches;
      }

There is one common trip-up in this function: ``for`` loops. In Zeek
scripts, using a for loop often loops over the *indexes* rather than
elements. That’s what the ``_`` in the ``for`` loop is: that’s an unused
index, which would often just count up from 0 each iteration. You can
add a second optional parameter, named ``pat`` in the function, which
contains the actual elements.

NOTE: Add Arne’s suggestion of a table[pattern] as an alternative in a
note?

Finally, call this new function when we finish collecting entity data:

   .. code:: zeek

      event http_end_entity(c: connection, is_orig: bool) {
          if (c?$http_state)
              print num_entity_pattern_matches(c$http_state);
      }

Now, because ``http_entity_patterns`` is marked with ``&redef``, you can
change its contents from other scripts or the command line.

   .. code:: console

      root@zeek-tutorial:/opt $ zeek -Cr traces/quickstart.pcap test.zeek
      0
      2
      0
      2

In this case, we will add three patterns, two of them will match. The
backslash characters (``\``) are used to escape angled brackets, since
this is invoked from a Bash shell:

   .. code:: console

      root@zeek-tutorial:/opt $ zeek -Cr traces/quickstart.pcap test.zeek “http_entity_patterns+={/\<html\>/, /Also does not match/, /\<title\>/}”
      0
      4
      0
      4

Finally, we have the core functionality for this script. The full script
at this point is here for your convenience. As before, this is also
available in the Docker image in
``/opt/scripting-tutorial/02-http-patterns.zeek``:

   .. code:: zeek

      export {
          option max_reassembled_entity_size = 10000 &redef;

          const http_entity_patterns: vector of pattern = {/Will not match!/, /<body>/, /301 Moved Permanently/};
      }

      redef record HTTP::State += {
          entity: string &default="";
      };

      function num_entity_pattern_matches(state: HTTP::State): count {
          local num_matches = 0;
          for (_, pat in http_entity_patterns) {
              if (pat in state$entity)
                  num_matches += 1;
          }

          return num_matches;
      }

      event http_entity_data(c: connection, is_orig: bool, length: count, data: string) {
          if ( c?$http_state ) {
              local remaining_available = max_reassembled_entity_size - |c$http_state$entity|;
              if (remaining_available <= 0) return;
              if (length < remaining_available)
                  c$http_state$entity += data;
              else
                  c$http_state$entity += data[:remaining_available];
          }
      }

      event http_end_entity(c: connection, is_orig: bool) {
          if (c?$http_state)
              print num_entity_pattern_matches(c$http_state);
      }

Modifying the Logs
==================

This script still prints information. It should, however, convey this
information in Zeek’s “native” form - logs. For this, we will take two
approaches: enriching the existing HTTP log, and using the notice
framework to deliver notices.

TODO: It may be nice to discuss when to use notices or when to add to
logs?

Adding a Log Field
------------------

Adding a log field to Zeek is actually very easy. Since we want to add
to the HTTP log, we will use the record that HTTP logs to - its ``Info``
record. First, we decide what we are logging - in this case, it’s just
the number of pattern matches. So, we add that to the HTTP::Info record
with ``redef``, and mark the field with ``&log`` to make sure it gets
logged:

   .. code:: zeek

      redef record HTTP::Info += {
          num_entity_matches: count &default=0 &log;
      };

Next, in ``http_end_entity``, set the field:

   .. code:: zeek

      event http_end_entity(c: connection, is_orig: bool) {
          if (c?$http_state && c?$http)
              c$http$num_entity_matches += num_entity_pattern_matches(c$http_state);
      }

We’re done! Log enrichment itself is simple - add the field to the
correct record. However, there are more considerations when making a
robust script. For example, there can be multiple entities for a given
HTTP request, so this script simply appends the matches to the previous
value.

If we run Zeek on the quickstart pcap:

   .. code:: console

      root@zeek-tutorial:/opt $ zeek -r quickstart.pcap

Then check for our new field in the logs:

   .. code:: console

      root@zeek-tutorial:/opt $ cat http.log | zeek-cut num_entity_matches
      2
      2

We see the matches were logged!

Generating a Notice
-------------------

Zeek also offers notices for various scenarios. These are outlined in
the Notice framework section. These are useful if there is some scenario
users may want to be notified about, like brute forcing passwords.
Notices can then be configured to take a specific action, like send an
email when it is generated. In this case, we will simply use it to raise
a notice when a certain threshold of matches are met.

To do this, first ``redef`` the ``Notice::Type`` with an extra value:

   .. code:: zeek

      redef enum Notice::Type += {
          Entity_Pattern_Threshold,
      };

Then, add another ``redef`` option for this threshold, still in the
export block:

   .. code:: zeek

      option pattern_threshold = 5 &redef;

Finally, we can test if this threshold was exceeded in
``http_end_entity``:

   .. code:: zeek

      event http_end_entity(c: connection, is_orig: bool) {
          if (c?$http_state && c?$http) {
              local num_entity_matches = num_entity_pattern_matches(c$http_state);
              c$http$num_entity_matches += num_entity_matches;
              if (num_entity_matches >= pattern_threshold)
                  NOTICE([$note=Entity_Pattern_Threshold,
                      $msg=fmt("Found %d pattern matches in HTTP entity.", num_entity_matches),
                      $id=c$id,
                      $identifier=cat(num_entity_matches, c$id$orig_h, c$id$resp_h)]);
          }
      }

This threshold only applies to a single entity, so if there are multiple
entities, each may exceed it.

Notices will, by default, get logged in ``notice.log``. You will notice
that no notice log exists when executed as-is:

   .. code:: console

      root@zeek-tutorial:/opt $ zeek test.zeek -r traces/quickstart.pcap
      root@zeek-tutorial:/opt $ cat notice.log
      cat: notice.log: No such file or directory

But, we can lower the threshold:

   .. code:: console

      root@zeek-tutorial:/opt $ zeek test.zeek -r traces/quickstart.pcap pattern_threshold=1
      root@zeek-tutorial:/opt $ cat notice.log
      #separator \x09
      … <cut for brevity>

The notice framework is a powerful way to inform analysts of interesting
events in various ways. For more information, read the section on the
notice framework.

With that, the script is done. Here it is in its entirety, or in
``scripting-tutorial/03-http-logging.zeek``:

   .. code:: zeek

      export {
          option max_reassembled_entity_size = 10000 &redef;
          option pattern_threshold = 5 &redef;

          const http_entity_patterns: vector of pattern = {/Will not match!/, /<body>/, /301 Moved Permanently/};

          redef enum Notice::Type += {
              Entity_Pattern_Threshold,
          };
      }

      redef record HTTP::State += {
          entity: string &default="";
      };

      redef record HTTP::Info += {
          num_entity_matches: count &default=0 &log;
      };

      function num_entity_pattern_matches(state: HTTP::State): count {
          local num_matches = 0;
          for (_, pat in http_entity_patterns) {
              if (pat in state$entity)
                  num_matches += 1;
          }

          return num_matches;
      }

      event http_entity_data(c: connection, is_orig: bool, length: count, data: string) {
          if ( c?$http_state ) {
              local remaining_available = max_reassembled_entity_size - |c$http_state$entity|;
              if (remaining_available <= 0) return;
              if (length < remaining_available)
                  c$http_state$entity += data;
              else
                  c$http_state$entity += data[:remaining_available];
          }
      }

      event http_end_entity(c: connection, is_orig: bool) {
          if (c?$http_state && c?$http) {
              local num_entity_matches = num_entity_pattern_matches(c$http_state);
              c$http$num_entity_matches += num_entity_matches;
              if (num_entity_matches >= pattern_threshold)
                  NOTICE([$note=Entity_Pattern_Threshold,
                      $msg=fmt("Found %d pattern matches in HTTP entity.", num_entity_matches),
                      $id=c$id,
                      $identifier=cat(num_entity_matches, c$id$orig_h, c$id$resp_h)]);
          }
      }

Conclusions
-----------

We went over how to use many of Zeek’s language features as well as ways
to expose the new analysis to users. There are ways to learn more about
Zeek scripting as well:

You can go through try.zeek.org - this is an interactive tutorial all in
the web browser. It explains Zeek’s functionality with increasingly
advanced scripts. That is a logical next step after this tutorial if
some language features seem under-explained. You can go through the
script reference section. This has detailed explanations of all of
Zeek’s operators, statements, declarations, and more. If you need a
deep-dive, that is the reference to use.

While this script is not necessarily production-capable, it uses Zeek in
many of the same ways you would for a real detection. Part of the reason
it’s not production-capable is that Zeek actually has better ways of
matching patterns on traffic and files - the Signature framework. In the
next section, we will discuss Zeek’s many frameworks and how to use some
of them.
