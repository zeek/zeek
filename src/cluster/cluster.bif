%%{
#include <string>

#include "zeek/cluster/Backend.h"
#include "zeek/cluster/BifSupport.h"

using namespace zeek::cluster::detail::bif;

%%}

module Cluster;

type Cluster::Event: record;

## Publishes an event to a given topic.
##
## topic: a topic associated with the event message.
##
## args: Either the event arguments as already made by
##       :zeek:see:`Cluster::make_event` or the argument list to pass along
##       to it.
##
## Returns: true if the message is sent.
function Cluster::publish%(topic: string, ...%): bool
	%{
	ScriptLocationScope scope{frame};

	auto args = zeek::ArgsSpan{*@ARGS@}.subspan(1);
	return publish_event({zeek::NewRef{}, topic}, args);
	%}

## Create a data structure that may be used to send a remote event via
## :zeek:see:`Broker::publish`.
##
## args: an event, followed by a list of argument values that may be used
##       to call it.
##
## Returns: A :zeek:type:`Cluster::Event` instance that can be published via
##          :zeek:see:`Cluster::publish`, :zeek:see:`Cluster::publish_rr`
##          or :zeek:see:`Cluster::publish_hrw`.
function Cluster::make_event%(...%): Cluster::Event
	%{
	ScriptLocationScope scope{frame};

	return make_event(zeek::ArgsSpan{*@ARGS@});
	%}

function Cluster::__subscribe%(topic_prefix: string%): bool
	%{
	ScriptLocationScope scope{frame};

	auto rval = zeek::cluster::backend->Subscribe(topic_prefix->CheckString());
	return zeek::val_mgr->Bool(rval);
	%}

function Cluster::__unsubscribe%(topic_prefix: string%): bool
	%{
	ScriptLocationScope scope{frame};

	auto rval = zeek::cluster::backend->Unsubscribe(topic_prefix->CheckString());
	return zeek::val_mgr->Bool(rval);
	%}

## Initialize the global cluster backend.
##
## Returns: true on success.
function Cluster::Backend::__init%(nid: string%): bool
	%{
	auto rval = zeek::cluster::backend->Init(nid->ToStdString());
	return zeek::val_mgr->Bool(rval);
	%}

type Cluster::Pool: record;

## Publishes an event to a node within a pool according to Round-Robin
## distribution strategy.
##
## pool: the pool of nodes that are eligible to receive the event.
##
## key: an arbitrary string to identify the purpose for which you're
##      distributing the event.  e.g. consider using namespacing of your
##      script like "Intel::cluster_rr_key".
##
## args: Either the event arguments as already made by
##       :zeek:see:`Cluster::make_event` or the argument list to pass along
##       to it.
##
## Returns: true if the message is sent.
function Cluster::publish_rr%(pool: Pool, key: string, ...%): bool
	%{
	static zeek::Func* topic_func = nullptr;

	if ( ! topic_func )
		topic_func = zeek::detail::global_scope()->Find("Cluster::rr_topic")->GetVal()->AsFunc();

	if ( ! is_cluster_pool(pool) )
		{
		zeek::emit_builtin_error("expected type Cluster::Pool for pool");
		return zeek::val_mgr->False();
		}

	zeek::Args vl{{zeek::NewRef{}, pool}, {zeek::NewRef{}, key}};
	auto topic = topic_func->Invoke(&vl);

	if ( ! topic->AsString()->Len() )
		return zeek::val_mgr->False();

	auto args = zeek::ArgsSpan{*@ARGS@}.subspan(2);
	return publish_event(topic, args);
	%}


## Publishes an event to a node within a pool according to Rendezvous
## (Highest Random Weight) hashing strategy.
##
## pool: the pool of nodes that are eligible to receive the event.
##
## key: data used for input to the hashing function that will uniformly
##      distribute keys among available nodes.
##
## args: Either the event arguments as already made by
##       :zeek:see:`Broker::make_event` or the argument list to pass along
##       to it.
##
## Returns: true if the message is sent.
function Cluster::publish_hrw%(pool: Pool, key: any, ...%): bool
	%{
	static zeek::Func* topic_func = nullptr;

	if ( ! topic_func )
		topic_func = zeek::detail::global_scope()->Find("Cluster::hrw_topic")->GetVal()->AsFunc();

	if ( ! is_cluster_pool(pool) )
		{
		zeek::emit_builtin_error("expected type Cluster::Pool for pool");
		return zeek::val_mgr->False();
		}

	zeek::Args vl{{zeek::NewRef{}, pool}, {zeek::NewRef{}, key}};
	auto topic = topic_func->Invoke(&vl);

	if ( ! topic->AsString()->Len() )
		return zeek::val_mgr->False();

	auto args = zeek::ArgsSpan{*@ARGS@}.subspan(2);

	ScriptLocationScope scope{frame};
	return publish_event(topic, args);
	%}
