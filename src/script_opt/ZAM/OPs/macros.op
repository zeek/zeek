# General-purpose macros. Those that are specific to a group of instructions
# are defined with those templates rather than appearing here.

# Macros for information associated with the current instruction.

# The Val frame used to pass in arguments.
macro Z_FRAME f

# The main type.
macro Z_TYPE z.GetType()

# Whether it's managed.
macro Z_IS_MANAGED *(z.is_managed)

# Secondary type.
macro Z_TYPE2 z.GetType2()

# Auxiliary information.
macro Z_AUX z.aux
macro Z_AUX_ID z.aux->id_val
macro Z_AUX_FUNC z.aux->func
macro Z_AUX_MAP z.aux->map
macro Z_AUX_ATTRS z.aux->attrs
macro Z_AUX_WHEN_INFO z.aux->wi
macro Z_AUX_EVENT_HANDLER z.aux->event_handler
macro Z_AUX_PRIMARY_FUNC z.aux->lambda->PrimaryFunc()
macro Z_AUX_LAMBDA_NAME z.aux->lambda->Name()

# Location in the original script.
macro Z_LOC z.loc

macro SET_RET_TYPE(type) ret_type = type;

macro INDEX_LIST zam_index_val_list

macro ERROR(msg) ZAM_run_time_error(Z_LOC, msg)
macro ERROR2(msg, obj) ZAM_run_time_error(Z_LOC, msg, obj)

macro WARN(msg) ZAM_run_time_warning(Z_LOC, msg)

# The following abstracts the process of creating a frame-assignable value.
macro BuildVal(v, t) ZVal(v, t)

# Returns a memory-managed-if-necessary copy of an existing value.
macro CopyVal(v) (Z_IS_MANAGED ? BuildVal((v).ToVal(Z_TYPE), Z_TYPE) : (v))

# Managed assignments to the given target.
macro AssignTarget(target, v) {
	if ( Z_IS_MANAGED )
		{
		/* It's important to hold a reference to v here prior
		   to the deletion in case target points to v. */
		auto v2 = v;
		ZVal::DeleteManagedType(target);
		target = v2;
		}
	else
		target = v;
	}

macro Branch(target) { DO_ZAM_PROFILE; pc = target; continue; }

macro REDO { --pc; /* so we then increment to here again */ break; }

macro GlobalID(g) globals[g].id
macro GlobalVal(g) frame[globals[g].slot]

macro StepIter(slot) step_iters[slot]
macro TableIter(slot) (*tiv_ptr)[slot]

macro RecordTypeField(rt, f) f
macro RecordField(r, f) RecordTypeField(r->GetType(), f)

# Yields a ZVal& of the field of the given record to assign to.
# Note that RawField() may unset callbacks if any are set, but
# that's okay if the field is to be assigned.
macro DirectField(r, f) r->RawField(RecordField(r, f))

# Yields a ZValElement&. Deferred initialization happens if
# it does not already hold a ZVal or callback. See
# RecordVal::RawOptField().
macro DirectOptField(r, f) r->RawOptField(RecordField(r, f))

# Load a field as ZVal from a record, taking into account field callbacks
# and falling back to fetch the default value, if any.
#
# target: ZVal object to be populated
# r: source record as RecordVal*
# f: field index as int
#
# zvel stands for ZValElement.
#
# Memory management: If target is a managed ZVal, the caller
#                    owns the returned reference. That is, there
#                    is no need to invoke zeek::Ref() on target.
macro LoadFieldWithDefault(target, r, f) {
	const auto& zvel = DirectOptField(r, f);
	if ( zvel.HoldsZVal() )
		{
		target = *zvel;
		if ( zvel.IsManaged() )
			zeek::Ref(target.ManagedVal());
		}
	else if ( zvel.HoldsFieldCallback() )
		{
		target = zvel.FieldCallback()->Invoke(*r, RecordField(r, f));
		}
	else
		{
		auto field = RecordField(r, f);
		auto def = r->GetType<RecordType>()->FieldDefault(field);
		if ( def )
			target = ZVal(def, Z_TYPE);
		else
			{
			ERROR(util::fmt("field value missing: $%s", r->GetType()->AsRecordType()->FieldName(field)));
			break;
			}
		}
	}

# Same as LoadFieldWithDefault(), but no default lookup.
macro LoadField(target, r, f) {
	const auto& zvel = DirectOptField(r, f);
	if ( zvel.HoldsZVal() )
		{
		target = *zvel;
		if ( zvel.IsManaged() )
			zeek::Ref(target.ManagedVal());
		}
	else if ( zvel.HoldsFieldCallback() )
		{
		target = zvel.FieldCallback()->Invoke(*r, RecordField(r, f));
		}
	else
		{
		ZAM_run_time_error(Z_LOC, "field value missing");
		break;
		}
	}

macro FieldValWithCheck(r, f) ZBody::CheckAndLookupField(r, f, Z_LOC)

macro LogEnum(v) v.ToVal(ZAM::log_ID_enum_type)
